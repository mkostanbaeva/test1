#Как реализованы callback`и

Технически существует много разных команд, каждая из которых работает с Elliptics по разному. То есть команды посылают разное количество транзакций, на разное количество серверов с разной логикой. Например, для ручки read запрос приходит на одну ноду, но если данные не находятся, то клиенту приходит ответ, что нет данных. Далее создается новая транзакция уже на другой сервер. С точки зрения протокола: есть serv, если id по каким-то причинам уходит в ринг-тайбл данной ноды (т.е. не он отвечает за этот id данной группы), то пересылается запрос другой ноде, которая ответит этой ноде и передаст клиенту (т.е. id не не найден, а просто не отвечает за него). 

Команды в Elliptics бывают разного уровня сложности: есть простые запросы, более сложные и запросы состоящии из запросов из первой категории. Простые запросы это фактически все ручки - write, stat_*, exec, iterator, remove, remov_indexes. Вторая категория запросов это ручки lookup, read, bulk_read, find. Третья категория это ручки prepare_latest, bulk_write, update/sd_indexes, write_cas, baeckend_*, chunked_write.

Это простые ручки и они паралельно посылают одну или более транзакции на один или более серверов, а в завершении приходит ответ. Или все запросы могут останавливаться по таймауту. Различий в ответе нет, если сервер вернул таймаут или какую-то ошибку - это одно и тоже.

>Вот тут далее у меня загвоздка какая то моральная как это плавно перевести в основной текст нормально.

Теперь на прямую с сишными методами в Elliptics работают не все callback, а только 4 метода - sendtosinglestate, sendtoeachbackend, sendtogroups, sendsrvcommand, которые возвращают asyncresult. Asyncresult это плюсовая абстракция, внутри себя  вызывающая сишные методы в соответствии с переданные им сишными структурами и описывающая процесс того где делается команда. Эти структуры подготавливаются в ручках для того чтобы рассказать как именно команда должна производиться на сервере. Сейчас команда напрямую передается в эти методы, а они уже напрямую передают в низкоуровневые сишные функции. Дальше существуют только один класс, который занимается обработкой ответов от сервера через сишные callbackи и он их превращает в плюсовые контейнеры, называемые callbackresultentry, которые уже дальше передают в плюсовый код. Тем самым взаимодействие с сишным кодом сведено только к реализации этих четырех методов. Каждая из последующих ручек можно также разделить на несколько иерархий. Но самая простая иерархия сейчас делает только следующие - подгатавливает транспорт transportcontrol, специального вида структурку, а  дальше вызывает один из методов sendtosinglestate, sendtoeachbackend, sendtogroups, sendsrvcommand, которые передают эту структурку. Результат превращает в asyncresult специализированный по нужному типу и отдает его пользователю. Более сложные ручки, которые посылают команда в разнве группы по очереди, такие как read/lookup/bulk_read реализованы в виде класса, который производит итерацию по группам и для каждой группы он вызывает виртуальный метод sendtonextgroup, внутри которого уже конкретная ручка реализовывается в логе - как послать запрос к эту группу. После чего возвращает asyncresult. Внутри этого метода вызываются все теже самые send to singlestate, sendtoeachbackend. Класс, который отвечает за итерирование по группам вызывает sendtogroups. Определеныый пользователь получает asyncresult - далее ждет когда этот asyncresult скажет, что он закончил обработку команды через специальные коннекты. И как только asyncresult сказал, что закончил обработкку ответов, он вызывает определенную пользователем ручку c вопросом - нужно ли делать запрос в следующую группу. Если пользовательский код говорит, что нужно, то он вызывает sendtogroups и так далее. Тем самым осуществляется перебор всех групп и в конце пользователю будет сообщена вся информация. Это переопредяет три ручки read/lookup/bulk_read. В lookup мы только переопределяем sendtonextgroup и посылаем в заданную группу  lookup по id при помощи sendtosinglestate. Класс определяет что пора остановиться по тому, что ручка говорит успешно или нет была ли проведен запрос в конкретно эту группу.  В read переопределены ручки process, aftergroup* для реализации dnetrecovery. В bulkread тоже переопределена ручка process чтобы убирать id из списка на запрос.

Методы sendtosinglestate, sendtoeachbackend и тд они возвращают asyncgenericresult, который специализирован по самому базову из всех типов callbackresultentry. При этом пользовательский код ожидает видеть  asyncresult специализированный по конкретном типу, например, asyncreadresult, asyncloockupresult. Для этого производится каст asyncgenericessult  в asyncresult и этот код созадает еще один asyncresult,  который каждый приiедший пакет от  asyncgenericessult проверяет на соответствие нужному типу. Все пакеты, которые соответствуют типу преобразовывается в соответствующий пакет, например callbackresultentry преобразовывает lookupresultentry и его уже передает в специализированный asyncresult. 

